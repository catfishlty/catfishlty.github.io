<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>容器 on Catfish</title><link>https://www.catfish.top/tags/%E5%AE%B9%E5%99%A8/</link><description>Recent content in 容器 on Catfish</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 23 Jul 2021 14:23:00 +0800</lastBuildDate><atom:link href="https://www.catfish.top/tags/%E5%AE%B9%E5%99%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes初探（九）</title><link>https://www.catfish.top/p/k8s-basic-9/</link><pubDate>Fri, 23 Jul 2021 14:23:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-9/</guid><description>Katacoda在线课：Running Stateful Services on Kubernetes
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
部署 NFS 服务器 NFS 是一种允许节点通过网络读 / 写数据的协议。该协议的工作原理是让主节点运行 NFS 守护程序并存储数据。此主节点使某些目录可通过网络使用。
客户端访问通过驱动器挂载共享的主服务器。从应用程序的角度来看，它们正在写入本地磁盘。在背后，NFS 协议将其写入主服务器。
任务 在此场景中，出于演示和学习目的，NFS 服务器的角色由自定义容器处理。容器通过 NFS 提供目录并将数据存储在容器内。在生产环境中，建议配置专用的 NFS Server。
使用 docker run -d --net=host \ --privileged --name nfs-server \ katacoda/contained-nfs-server:centos7 \ /exports/data-0001 /exports/data-0002 命令启动 NFS 服务器
controlplane $ docker run -d --net=host \ &amp;gt; --privileged --name nfs-server \ &amp;gt; katacoda/contained-nfs-server:centos7 \ &amp;gt; /exports/data-0001 /exports/data-0002 Unable to find image &amp;#39;katacoda/contained-nfs-server:centos7&amp;#39; locally centos7: Pulling from katacoda/contained-nfs-server 8d30e94188e7: Pull complete 2b2b27f1f462: Pull complete 133e63cf95fe: Pull complete Digest: sha256:5f2ea4737fe27f26be5b5cabaa23e24180079a4dce8d5db235492ec48c5552d1 Status: Downloaded newer image for katacoda/contained-nfs-server:centos7 65699a0a96bfc489fe2141a815ef12b03917f9bb667340b1be68dfe838d14bf3 NFS 服务器公开两个目录，data-0001 和 data-0002。在接下来的步骤中，这将用于存储数据。</description></item><item><title>Kubernetes初探（八）</title><link>https://www.catfish.top/p/k8s-basic-8/</link><pubDate>Fri, 23 Jul 2021 13:07:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-8/</guid><description>Katacoda在线课：Liveness and Readiness Healthchecks
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将了解 Kubernetes 如何使用 Readiness and Liveness Probes 检查容器运行状况。
Readiness Probe 检查应用是否准备好开始处理流量。此探针解决了容器已启动的问题，但该进程仍在预热和配置自身，这意味着它尚未准备好接收流量。
Liveness Probe 确保应用程序健康并能够处理请求。
启动集群 首先，我们需要启动一个 Kubernetes 集群。
执行以下命令启动集群组件并下载 Kubectl CLI
controlplane $ launch.sh Waiting for Kubernetes to start... Kubernetes started 集群启动后，使用 kubectl apply -f deploy.yaml 部署演示应用程序。
deploy.yaml
kind:ListapiVersion:v1items:- kind:ReplicationControllerapiVersion:v1metadata:name:frontendlabels:name:frontendspec:replicas:1selector:name:frontendtemplate:metadata:labels:name:frontendspec:containers:- name:frontendimage:katacoda/docker-http-server:healthreadinessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1livenessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1- kind:ReplicationControllerapiVersion:v1metadata:name:bad-frontendlabels:name:bad-frontendspec:replicas:1selector:name:bad-frontendtemplate:metadata:labels:name:bad-frontendspec:containers:- name:bad-frontendimage:katacoda/docker-http-server:unhealthyreadinessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1livenessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1- kind:ServiceapiVersion:v1metadata:labels:app:frontendkubernetes.io/cluster-service:&amp;#34;true&amp;#34;name:frontendspec:type:NodePortports:- port:80nodePort:30080selector:app:frontendcontrolplane $ kubectl apply -f deploy.yaml replicationcontroller/frontend created replicationcontroller/bad-frontend created service/frontend created Readiness Probe 在部署集群时，还部署了两个 Pod 来演示健康检查。您可以使用 cat deploy.</description></item><item><title>Kubernetes初探（七）</title><link>https://www.catfish.top/p/k8s-basic-7/</link><pubDate>Tue, 20 Jul 2021 15:30:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-7/</guid><description>Katacoda在线课：Create Ingress Routing
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
Kubernetes 具有先进的网络功能，允许 Pod 和 Service 在集群网络内部进行通信。 Ingress 开启了到集群的入站连接，允许外部流量到达正确的 Pod。
Ingress 能够提供外部可访问的 URL、负载平衡流量、终止 SSL、为 Kubernetes 集群提供基于名称的虚拟主机。
在此场景中，您将学习如何部署和配置 Ingress 规则来管理传入的 HTTP 请求。
创建 Deployment 首先，部署一个示例 HTTP 服务器，它将成为我们请求的目标。部署中包含三个部署，分别为 webapp1， webapp2， webapp3，每个部署都有一个服务。
deployment.yaml
apiVersion:apps/v1kind:Deploymentmetadata:name:webapp1spec:replicas:1selector:matchLabels:app:webapp1template:metadata:labels:app:webapp1spec:containers:- name:webapp1image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:apps/v1kind:Deploymentmetadata:name:webapp2spec:replicas:1selector:matchLabels:app:webapp2template:metadata:labels:app:webapp2spec:containers:- name:webapp2image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:apps/v1kind:Deploymentmetadata:name:webapp3spec:replicas:1selector:matchLabels:app:webapp3template:metadata:labels:app:webapp3spec:containers:- name:webapp3image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:v1kind:Servicemetadata:name:webapp1-svclabels:app:webapp1spec:ports:- port:80selector:app:webapp1---apiVersion:v1kind:Servicemetadata:name:webapp2-svclabels:app:webapp2spec:ports:- port:80selector:app:webapp2---apiVersion:v1kind:Servicemetadata:name:webapp3-svclabels:app:webapp3spec:ports:- port:80selector:app:webapp3任务 使用 kubectl apply -f deployment.yaml 命令部署 YAML 定义。
controlplane $ kubectl apply -f deployment.yaml deployment.apps/webapp1 created deployment.apps/webapp2 created deployment.apps/webapp3 created service/webapp1-svc created service/webapp2-svc created service/webapp3-svc created 可以用 kubectl get deployment 查看状态。</description></item><item><title>Kubernetes初探（六）</title><link>https://www.catfish.top/p/k8s-basic-6/</link><pubDate>Tue, 20 Jul 2021 13:36:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-6/</guid><description>Katacoda在线课：Networking Introduction
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
Kubernetes 具有先进的网络功能，允许 Pod 和 Service 在集群网络内部和外部进行通信。
在此场景中，您将学习以下类型的 Kubernetes Service。
Cluster IP Target Ports NodePort External IPs Load Balancer Kubernetes 服务是一个抽象，它定义了如何访问一组 Pod 的策略和方法。可以通过 Service 访问基于标签选择器的 Pod 集合。
Cluster IP Cluster IP 是创建 Kubernetes 服务时的默认方法。该服务被分配了一个内部 IP，其他组件可以使用它来访问 Pod。
Service 能够通过单个 IP 地址在多个 Pod 之间进行负载平衡。
通过 kubectl apply -f clusterip.yaml 命令部署服务。
在 cat clusterip.yaml 可以查看相关定义。
clusterip.yaml
apiVersion:v1kind:Servicemetadata:name:webapp1-clusterip-svclabels:app:webapp1-clusteripspec:ports:- port:80selector:app:webapp1-clusterip---apiVersion:extensions/v1beta1kind:Deploymentmetadata:name:webapp1-clusterip-deploymentspec:replicas:2template:metadata:labels:app:webapp1-clusteripspec:containers:- name:webapp1-clusterip-podimage:katacoda/docker-http-server:latestports:- containerPort:80---controlplane $ kubectl apply -f clusterip.</description></item><item><title>Kubernetes初探（五）</title><link>https://www.catfish.top/p/k8s-basic-5/</link><pubDate>Tue, 20 Jul 2021 13:18:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-5/</guid><description>Katacoda在线课：Deploy Guestbook Web App Example
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
本场景说明了如何使用 Kubernetes 和 Docker 启动简单的多层 Web 应用。留言簿示例应用程序通过调用* JavaScript API* 将访客的笔记存储在 *Redis* 中。 *Redis* 包含一个 master（用于存储）和一组 *slave* 复制集。
核心概念 在此场景中将涵盖以下核心概念。这些是理解 Kubernetes 的基础。
Pods Replication Controllers Services NodePorts 启动 Kubernetes 首先，我们需要一个正在运行的 Kubernetes 集群。详细信息在 Launch Kubernetes cluster
任务 使用初始化程序脚本启动单节点集群。初始化脚本将启动 API、Master、Proxy 和 DNS Discovery。 Web App 使用 DNS Discovery 来查找 Redis slave 来存储数据。
launch.sh 健康检查 使用 kubectl cluster-info 和 kubectl get nodes命令来检查部署的集群的节点健康信息。</description></item><item><title>Kubernetes初探（四）</title><link>https://www.catfish.top/p/k8s-basic-4/</link><pubDate>Tue, 20 Jul 2021 11:39:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-4/</guid><description>Katacoda在线课：Deploy Containers Using YAML
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将学习如何使用 Kubectl 创建和启动 Deployment、Replication Controller，并通过编写 yaml 定义使用服务开暴露它们。
YAML 定义了计划部署的 Kubernetes 对象。可以以更新对象并将其重新部署到集群的方式来更改配置。
创建 Deployment Deployment 对象是最常见的 Kubernetes 对象之一。Deployment 对象定义了所需的容器规范，以及 Kubernetes 其他部分用来发现和连接到应用程序的名称和标签。
任务 将以下定义复制到编辑器的YAML文件中。该 YAML 定义了如何使用在端口 80 上运行的应用，该应用使用 Docker 映像 katacoda/docker-http-server ，启动名为 webapp1 。
deployment.yaml
apiVersion:apps/v1kind:Deploymentmetadata:name:webapp1spec:replicas:1selector:matchLabels:app:webapp1template:metadata:labels:app:webapp1spec:containers:- name:webapp1image:katacoda/docker-http-server:latestports:- containerPort:80使用 kubectl create -f deployment.yaml 命令向集群部署。
$ kubectl create -f deployment.yaml deployment.apps/webapp1 created 由于它是一个 Deployment 对象，因此可以通过 kubectl get deployment 获取所有已部署的 Deployment 对象的列表。
$ kubectl get deployment NAME READY UP-TO-DATE AVAILABLE AGE webapp1 1/1 1 1 10s 可以使用 kubectl describe deployment webapp1 输出单个部署的详细信息。</description></item><item><title>Kubernetes初探（三）</title><link>https://www.catfish.top/p/k8s-basic-3/</link><pubDate>Tue, 20 Jul 2021 11:27:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-3/</guid><description>Katacoda在线课：Deploy Containers Using Kubectl
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，将学习如何使用 Kubectl 创建和启动 Deployment 和 Replication Controllers 并通过 Services 对外暴露接口。本场景中无需编写 yaml 定义，便可以快速将容器启动到集群上。
启动集群 首先，我们需要启动一个 Kubernetes 集群。
执行以下命令启动集群并下载 Kubectl CLI。
$ minikube start --wait=false * minikube v1.8.1 on Ubuntu 18.04 * Using the none driver based on user configuration * Running on localhost (CPUs=2, Memory=2460MB, Disk=145651MB) ... * OS release is Ubuntu 18.04.4 LTS * Preparing Kubernetes v1.17.3 on Docker 19.03.6 .</description></item><item><title>Kubernetes初探（二）</title><link>https://www.catfish.top/p/k8s-basic-2/</link><pubDate>Tue, 20 Jul 2021 11:05:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-2/</guid><description>Katacoda在线课：Launch a multi-node cluster using Kubeadm
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将学习如何使用 Kubeadm 启动 Kubernetes 集群。
Kubeadm 解决了TLS 加密配置、 Kubernetes 核心组件部署和额外节点集群加入的问题。启动的集群通过 RBAC 等机制开箱即用。
关于 Kubeadm 的更多信息可以参考： https://github.com/kubernetes/kubeadm
初始化 Master Kubeadm 已经安装在节点上。软件包适用于 Ubuntu 16.04+、CentOS 7 或 HypriotOS v1.0.1+。
初始化集群的第一步是启动 Master节点 。 Master节点 负责运行控制平面组件、etcd 和 API 服务器。客户端能够与 API 通信，能够完成工作负载的调度和集群状态的管理。
任务 下面的命令将使用已知的 Token 简化初始化集群的步骤。
controlplane $ kubeadm init --token=102952.1a7dd4cc8d1f4cc5 --kubernetes-version $(kubeadm version -o short) [init] Using Kubernetes version: v1.14.0 [preflight] Running pre-flight checks [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using &amp;#39;kubeadm config images pull&amp;#39; [kubelet-start] Writing kubelet environment file with flags to file &amp;#34;/var/lib/kubelet/kubeadm-flags.</description></item><item><title>Kubernetes初探（一）</title><link>https://www.catfish.top/p/k8s-basic-1/</link><pubDate>Tue, 20 Jul 2021 10:21:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-1/</guid><description>Katacoda在线课：Launch A Single Node Cluster
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
Minikube 是一个可以轻松在本地运行 Kubernetes 的工具。 Minikube 是一个在本地上计算机的虚拟机内运行一个单节点 Kubernetes 集群，便于用户能够完成日常开发工作，同时也能够让新用户快速了解 Kubernetes 。
详情见： https://github.com/kubernetes/minikube
步骤 1 - 启动 Minikube Minikube 已经安装并配置到环境中。通过运行 minikube version 命令检查它是否已正确安装。
$ minikube version minikube version: v1.8.1 commit: cbda04cf6bbe65e987ae52bb393c10099ab62014 通过运行 minikube start 命令启动集群。
$ minikube start --wait=false * minikube v1.8.1 on Ubuntu 18.04 * Using the none driver based on user configuration * Running on localhost (CPUs=2, Memory=2460MB, Disk=145651MB) .</description></item></channel></rss>