<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>YAML on Catfish</title><link>https://www.catfish.top/tags/yaml/</link><description>Recent content in YAML on Catfish</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 23 Jul 2021 14:54:00 +0800</lastBuildDate><atom:link href="https://www.catfish.top/tags/yaml/index.xml" rel="self" type="application/rss+xml"/><item><title>Kubernetes初探（十一）</title><link>https://www.catfish.top/p/k8s-basic-11/</link><pubDate>Fri, 23 Jul 2021 14:54:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-11/</guid><description>Katacoda在线课：Helm Package Manager
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
这个场景教你如何使用 Kubernetes 的包管理器 Helm 来部署 Redis。 Helm 简化了服务发现和部署到 Kubernetes 集群的步骤。。
&amp;ldquo;Helm is the best way to find, share, and use software built for Kubernetes.&amp;quot;
Helm 是查找、共享和使用为 Kubernetes 构建的软件的最佳方式
更多细节可以前往官网：http://www.helm.sh/
安装 Helm Helm 是一个单独的二进制文件，用于管理将 Charts 部署到 Kubernetes。 Chart 是 kubernetes 应用的一个打包单元。Helm 可以从 https://github.com/kubernetes/helm/releases 下载。
controlplane $ curl -LO https://storage.googleapis.com/kubernetes-helm/helm-v2.8.2-linux-amd64.tar.gz % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 14.</description></item><item><title>Kubernetes初探（十）</title><link>https://www.catfish.top/p/k8s-basic-10/</link><pubDate>Fri, 23 Jul 2021 14:54:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-10/</guid><description>Katacoda在线课：Use Kubernetes To Manage Secrets And Passwords
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将了解如何使用 Kubernetes 管理 Secrets 。 Kubernetes 允许您创建通过环境变量或作为卷挂载到 Pod 的 Secrets 。
只允许 Secrets （例如 SSL 证书或密码）通过基础架构团队以安全的方式进行管理，而不是将密码存储在应用程序的部署工件中。
启动 Kubernetes 首先，我们需要启动一个 Kubernetes 集群。
执行以下命令启动集群组件并下载 Kubectl CLI。
controlplane $ launch.sh Waiting for Kubernetes to start... Kubernetes started 创建 Secrets Kubernetes 要求将 Secrets 编码为 Base64 的字符串。
使用命令行工具，我们可以创建 Base64 字符串并将它们存储为变量在文件中使用。
controlplane $ username=$(echo -n &amp;#34;admin&amp;#34; | base64) controlplane $ password=$(echo -n &amp;#34;a62fjbd37942dcs&amp;#34; | base64) Secrets 是使用 YAML 定义的。下面我们将使用上面定义的变量，并为它们提供我们的应用程序可以使用的标签。这将创建一个可以通过名称访问的键/值秘密的集合。</description></item><item><title>Kubernetes初探（九）</title><link>https://www.catfish.top/p/k8s-basic-9/</link><pubDate>Fri, 23 Jul 2021 14:23:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-9/</guid><description>Katacoda在线课：Running Stateful Services on Kubernetes
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
部署 NFS 服务器 NFS 是一种允许节点通过网络读 / 写数据的协议。该协议的工作原理是让主节点运行 NFS 守护程序并存储数据。此主节点使某些目录可通过网络使用。
客户端访问通过驱动器挂载共享的主服务器。从应用程序的角度来看，它们正在写入本地磁盘。在背后，NFS 协议将其写入主服务器。
任务 在此场景中，出于演示和学习目的，NFS 服务器的角色由自定义容器处理。容器通过 NFS 提供目录并将数据存储在容器内。在生产环境中，建议配置专用的 NFS Server。
使用 docker run -d --net=host \ --privileged --name nfs-server \ katacoda/contained-nfs-server:centos7 \ /exports/data-0001 /exports/data-0002 命令启动 NFS 服务器
controlplane $ docker run -d --net=host \ &amp;gt; --privileged --name nfs-server \ &amp;gt; katacoda/contained-nfs-server:centos7 \ &amp;gt; /exports/data-0001 /exports/data-0002 Unable to find image &amp;#39;katacoda/contained-nfs-server:centos7&amp;#39; locally centos7: Pulling from katacoda/contained-nfs-server 8d30e94188e7: Pull complete 2b2b27f1f462: Pull complete 133e63cf95fe: Pull complete Digest: sha256:5f2ea4737fe27f26be5b5cabaa23e24180079a4dce8d5db235492ec48c5552d1 Status: Downloaded newer image for katacoda/contained-nfs-server:centos7 65699a0a96bfc489fe2141a815ef12b03917f9bb667340b1be68dfe838d14bf3 NFS 服务器公开两个目录，data-0001 和 data-0002。在接下来的步骤中，这将用于存储数据。</description></item><item><title>Kubernetes初探（八）</title><link>https://www.catfish.top/p/k8s-basic-8/</link><pubDate>Fri, 23 Jul 2021 13:07:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-8/</guid><description>Katacoda在线课：Liveness and Readiness Healthchecks
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将了解 Kubernetes 如何使用 Readiness and Liveness Probes 检查容器运行状况。
Readiness Probe 检查应用是否准备好开始处理流量。此探针解决了容器已启动的问题，但该进程仍在预热和配置自身，这意味着它尚未准备好接收流量。
Liveness Probe 确保应用程序健康并能够处理请求。
启动集群 首先，我们需要启动一个 Kubernetes 集群。
执行以下命令启动集群组件并下载 Kubectl CLI
controlplane $ launch.sh Waiting for Kubernetes to start... Kubernetes started 集群启动后，使用 kubectl apply -f deploy.yaml 部署演示应用程序。
deploy.yaml
kind:ListapiVersion:v1items:- kind:ReplicationControllerapiVersion:v1metadata:name:frontendlabels:name:frontendspec:replicas:1selector:name:frontendtemplate:metadata:labels:name:frontendspec:containers:- name:frontendimage:katacoda/docker-http-server:healthreadinessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1livenessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1- kind:ReplicationControllerapiVersion:v1metadata:name:bad-frontendlabels:name:bad-frontendspec:replicas:1selector:name:bad-frontendtemplate:metadata:labels:name:bad-frontendspec:containers:- name:bad-frontendimage:katacoda/docker-http-server:unhealthyreadinessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1livenessProbe:httpGet:path:/port:80initialDelaySeconds:1timeoutSeconds:1- kind:ServiceapiVersion:v1metadata:labels:app:frontendkubernetes.io/cluster-service:&amp;#34;true&amp;#34;name:frontendspec:type:NodePortports:- port:80nodePort:30080selector:app:frontendcontrolplane $ kubectl apply -f deploy.yaml replicationcontroller/frontend created replicationcontroller/bad-frontend created service/frontend created Readiness Probe 在部署集群时，还部署了两个 Pod 来演示健康检查。您可以使用 cat deploy.</description></item><item><title>Kubernetes初探（七）</title><link>https://www.catfish.top/p/k8s-basic-7/</link><pubDate>Tue, 20 Jul 2021 15:30:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-7/</guid><description>Katacoda在线课：Create Ingress Routing
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
Kubernetes 具有先进的网络功能，允许 Pod 和 Service 在集群网络内部进行通信。 Ingress 开启了到集群的入站连接，允许外部流量到达正确的 Pod。
Ingress 能够提供外部可访问的 URL、负载平衡流量、终止 SSL、为 Kubernetes 集群提供基于名称的虚拟主机。
在此场景中，您将学习如何部署和配置 Ingress 规则来管理传入的 HTTP 请求。
创建 Deployment 首先，部署一个示例 HTTP 服务器，它将成为我们请求的目标。部署中包含三个部署，分别为 webapp1， webapp2， webapp3，每个部署都有一个服务。
deployment.yaml
apiVersion:apps/v1kind:Deploymentmetadata:name:webapp1spec:replicas:1selector:matchLabels:app:webapp1template:metadata:labels:app:webapp1spec:containers:- name:webapp1image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:apps/v1kind:Deploymentmetadata:name:webapp2spec:replicas:1selector:matchLabels:app:webapp2template:metadata:labels:app:webapp2spec:containers:- name:webapp2image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:apps/v1kind:Deploymentmetadata:name:webapp3spec:replicas:1selector:matchLabels:app:webapp3template:metadata:labels:app:webapp3spec:containers:- name:webapp3image:katacoda/docker-http-server:latestports:- containerPort:80---apiVersion:v1kind:Servicemetadata:name:webapp1-svclabels:app:webapp1spec:ports:- port:80selector:app:webapp1---apiVersion:v1kind:Servicemetadata:name:webapp2-svclabels:app:webapp2spec:ports:- port:80selector:app:webapp2---apiVersion:v1kind:Servicemetadata:name:webapp3-svclabels:app:webapp3spec:ports:- port:80selector:app:webapp3任务 使用 kubectl apply -f deployment.yaml 命令部署 YAML 定义。
controlplane $ kubectl apply -f deployment.yaml deployment.apps/webapp1 created deployment.apps/webapp2 created deployment.apps/webapp3 created service/webapp1-svc created service/webapp2-svc created service/webapp3-svc created 可以用 kubectl get deployment 查看状态。</description></item><item><title>Kubernetes初探（六）</title><link>https://www.catfish.top/p/k8s-basic-6/</link><pubDate>Tue, 20 Jul 2021 13:36:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-6/</guid><description>Katacoda在线课：Networking Introduction
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
Kubernetes 具有先进的网络功能，允许 Pod 和 Service 在集群网络内部和外部进行通信。
在此场景中，您将学习以下类型的 Kubernetes Service。
Cluster IP Target Ports NodePort External IPs Load Balancer Kubernetes 服务是一个抽象，它定义了如何访问一组 Pod 的策略和方法。可以通过 Service 访问基于标签选择器的 Pod 集合。
Cluster IP Cluster IP 是创建 Kubernetes 服务时的默认方法。该服务被分配了一个内部 IP，其他组件可以使用它来访问 Pod。
Service 能够通过单个 IP 地址在多个 Pod 之间进行负载平衡。
通过 kubectl apply -f clusterip.yaml 命令部署服务。
在 cat clusterip.yaml 可以查看相关定义。
clusterip.yaml
apiVersion:v1kind:Servicemetadata:name:webapp1-clusterip-svclabels:app:webapp1-clusteripspec:ports:- port:80selector:app:webapp1-clusterip---apiVersion:extensions/v1beta1kind:Deploymentmetadata:name:webapp1-clusterip-deploymentspec:replicas:2template:metadata:labels:app:webapp1-clusteripspec:containers:- name:webapp1-clusterip-podimage:katacoda/docker-http-server:latestports:- containerPort:80---controlplane $ kubectl apply -f clusterip.</description></item><item><title>Kubernetes初探（五）</title><link>https://www.catfish.top/p/k8s-basic-5/</link><pubDate>Tue, 20 Jul 2021 13:18:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-5/</guid><description>Katacoda在线课：Deploy Guestbook Web App Example
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
本场景说明了如何使用 Kubernetes 和 Docker 启动简单的多层 Web 应用。留言簿示例应用程序通过调用* JavaScript API* 将访客的笔记存储在 *Redis* 中。 *Redis* 包含一个 master（用于存储）和一组 *slave* 复制集。
核心概念 在此场景中将涵盖以下核心概念。这些是理解 Kubernetes 的基础。
Pods Replication Controllers Services NodePorts 启动 Kubernetes 首先，我们需要一个正在运行的 Kubernetes 集群。详细信息在 Launch Kubernetes cluster
任务 使用初始化程序脚本启动单节点集群。初始化脚本将启动 API、Master、Proxy 和 DNS Discovery。 Web App 使用 DNS Discovery 来查找 Redis slave 来存储数据。
launch.sh 健康检查 使用 kubectl cluster-info 和 kubectl get nodes命令来检查部署的集群的节点健康信息。</description></item><item><title>Kubernetes初探（四）</title><link>https://www.catfish.top/p/k8s-basic-4/</link><pubDate>Tue, 20 Jul 2021 11:39:00 +0800</pubDate><guid>https://www.catfish.top/p/k8s-basic-4/</guid><description>Katacoda在线课：Deploy Containers Using YAML
本系列教程希望能通过交互式学习网站与传统方式结合，更高效、容易的学习知识。 本系列教程将使用 Katacoda在线学习平台 完成学习。
在此场景中，您将学习如何使用 Kubectl 创建和启动 Deployment、Replication Controller，并通过编写 yaml 定义使用服务开暴露它们。
YAML 定义了计划部署的 Kubernetes 对象。可以以更新对象并将其重新部署到集群的方式来更改配置。
创建 Deployment Deployment 对象是最常见的 Kubernetes 对象之一。Deployment 对象定义了所需的容器规范，以及 Kubernetes 其他部分用来发现和连接到应用程序的名称和标签。
任务 将以下定义复制到编辑器的YAML文件中。该 YAML 定义了如何使用在端口 80 上运行的应用，该应用使用 Docker 映像 katacoda/docker-http-server ，启动名为 webapp1 。
deployment.yaml
apiVersion:apps/v1kind:Deploymentmetadata:name:webapp1spec:replicas:1selector:matchLabels:app:webapp1template:metadata:labels:app:webapp1spec:containers:- name:webapp1image:katacoda/docker-http-server:latestports:- containerPort:80使用 kubectl create -f deployment.yaml 命令向集群部署。
$ kubectl create -f deployment.yaml deployment.apps/webapp1 created 由于它是一个 Deployment 对象，因此可以通过 kubectl get deployment 获取所有已部署的 Deployment 对象的列表。
$ kubectl get deployment NAME READY UP-TO-DATE AVAILABLE AGE webapp1 1/1 1 1 10s 可以使用 kubectl describe deployment webapp1 输出单个部署的详细信息。</description></item></channel></rss>