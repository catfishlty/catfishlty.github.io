<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="JVM垃圾回收器 G1 介绍"><title>JVM 垃圾回收器 - G1 （一）</title>
<link rel=canonical href=https://www.catfish.top/p/jvm-gc-g1-1/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="JVM 垃圾回收器 - G1 （一）">
<meta property="og:description" content="JVM垃圾回收器 G1 介绍">
<meta property="og:url" content="https://www.catfish.top/p/jvm-gc-g1-1/">
<meta property="og:site_name" content="Catfish">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="JVM"><meta property="article:tag" content="GC"><meta property="article:tag" content="G1"><meta property="article:published_time" content="2021-08-09T10:33:00+08:00"><meta property="article:modified_time" content="2021-08-19T10:35:00+08:00"><meta property="og:image" content="https://www.catfish.top/p/jvm-gc-g1-1/jvm-black.jpeg">
<meta name=twitter:title content="JVM 垃圾回收器 - G1 （一）">
<meta name=twitter:description content="JVM垃圾回收器 G1 介绍"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://www.catfish.top/p/jvm-gc-g1-1/jvm-black.jpeg">
<link rel="shortcut icon" href=/favicon.ico>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MPS4W3GMH8"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-MPS4W3GMH8')</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://www.catfish.top class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/p/jvm-gc-g1-1/>
<img src=/p/jvm-gc-g1-1/jvm-black_hu477442ae6bda7bfc8bc3ac8fce34800c_43268_800x0_resize_q75_box.jpeg srcset="/p/jvm-gc-g1-1/jvm-black_hu477442ae6bda7bfc8bc3ac8fce34800c_43268_800x0_resize_q75_box.jpeg 800w, /p/jvm-gc-g1-1/jvm-black_hu477442ae6bda7bfc8bc3ac8fce34800c_43268_1600x0_resize_q75_box.jpeg 1600w" width=800 height=450 loading=lazy alt="Featured image of post JVM 垃圾回收器 - G1 （一）">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/jvm/>
JVM
</a>
<a href=/categories/gc/>
GC
</a>
</header>
<h2 class=article-title>
<a href=/p/jvm-gc-g1-1/>JVM 垃圾回收器 - G1 （一）</a>
</h2>
<h3 class=article-subtitle>
JVM垃圾回收器 G1 介绍
</h3>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 09, 2021</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p><em>G1 GC</em>，全称 <em>Garbage-First Garbage Collector</em>，通过 <code>-XX:+UseG1GC</code>参数来启用。
它是专门针对以下应用场景设计的:</p>
<ul>
<li>像 <em>CMS</em> 收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要 <em>GC</em> 停顿时间更好预测。
不希望牺牲大量的吞吐性能。
不需要更大的 <em>Java</em> 堆内存。</li>
</ul>
<p><em>G1</em> 收集器的设计目标是取代 <em>CMS</em> 收集器，它同 <em>CMS</em> 相比，在以下方面表现的更出色： <em>G1</em> 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 <em>G1</em> 的 <em>Stop The World(STW)</em> 更可控，<em>G1</em> 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p>
<h2 id=重要概念>重要概念</h2>
<h3 id=region>Region</h3>
<p>传统的 <em>GC</em> 收集器将连续的内存空间划分为新生代、老年代和永久代（<em>JDK 8</em> 去除了永久代，引入了元空间 <em>Metaspace</em> ），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：</p>
<p><figure style=flex-grow:235;flex-basis:564px>
<a href=/p/jvm-gc-g1-1/jdk8-mem.png data-size=496x211><img src=/p/jvm-gc-g1-1/jdk8-mem.png srcset="/p/jvm-gc-g1-1/jdk8-mem_hue29f4098db7ced6aa09e9e84e752a07c_11885_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk8-mem_hue29f4098db7ced6aa09e9e84e752a07c_11885_1024x0_resize_box_3.png 1024w" width=496 height=211 loading=lazy alt="JDK 8 Memory Structure">
</a>
<figcaption>JDK 8 Memory Structure</figcaption>
</figure></p>
<p>而 <em>G1</em> 的各代存储地址是不连续的，每一代都使用了 <em>n</em> 个不连续的大小相同的 <em>Region</em>，每个* Region* 占有一块连续的虚拟内存地址。如下图所示：</p>
<p><figure style=flex-grow:143;flex-basis:344px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-mem.png data-size=461x321><img src=/p/jvm-gc-g1-1/jdk-g1-gc-mem.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-mem_hub5a2f6a3bbb07ed0c6bb6af21d0ab432_14229_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-mem_hub5a2f6a3bbb07ed0c6bb6af21d0ab432_14229_1024x0_resize_box_3.png 1024w" width=461 height=321 loading=lazy alt="JDK 8 G1 GC Memory Structure">
</a>
<figcaption>JDK 8 G1 GC Memory Structure</figcaption>
</figure></p>
<p><em>G1</em> 的堆结构就是把一整块内存区域切分成多个固定大小的块，每一块被称为一个 <em>Region</em> 。在JVM在启动时来决定每个小块，也就是 <em>Region</em> 的大小。 JVM一般是把一整块堆切分成大约 <em>2000</em> 个 <em>Region</em> 。每个小 <em>Region</em> 从 <em>1</em> 到 <em>32Mb</em> 不等，且是 <em>2</em> 的指数，如果不设定，那么G1会根据Heap大小自动决定。这些 <em>Region</em> 最后又被分别标记为<em>Eden</em> , <em>Survivor</em> 和 <em>Old</em> 。这里的 <em>Eden</em> ， <em>Survivor</em> 和old已经是一个标签，也就是说只是一个逻辑表示，不是物理表示。<em>O</em>表示老生代（ <em>Old</em> ），<em>E</em>表示 <em>Eden</em> ，<em>S</em>表示 <em>Survivor</em> 。为了明了，我们分别用三种不同的颜色区分。存活下来的对象就被虚拟机从一个 <em>Region</em> 里被移动到另一个中。这些小块 <em>Region</em> 的回收是并行回收的，期间其他的应用线程照常工作。和以往的回收器一样， <em>G1</em> 中也有 <em>Eden</em> , <em>Survivor</em> , <em>Old</em> 。在这三个之外，还增加了第四种类型，叫 <em>Humongous</em> 。这个单词翻译过来就是“堆积如山”的意思。这个类型主要是用来存储那些比标准块大50%，甚至更大的那些对象。这些大对象被保存到一整块连续的区域。这个堆积如山区就是堆里没有被使用的区域。记住一点： <em>G1</em> 不是像老一辈的那些垃圾回收器一样要求每一代的块是连续的，在 <em>G1</em> 中可以不是连续的。</p>
<h3 id=stab>STAB</h3>
<p><em>Snapshot-At-The-Beginning</em> ，由字面理解，是 <em>GC</em> 开始时活着的对象的一个快照。它是通过<em>Root Tracing</em> 得到的，作用是维持并发 <em>GC</em> 的正确性。
根据三色标记算法，我们知道对象存在三种状态：</p>
<ul>
<li><strong>白</strong>：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。</li>
<li><strong>灰</strong>：对象被标记了，但是它的field还没有被标记或标记完。</li>
<li><strong>黑</strong>：对象被标记了，且它的所有field也被标记完了。</li>
</ul>
<p>由于并发阶段的存在，<em>Mutator</em> 和 <em>Garbage Collector</em> 线程同时对对象进行修改，就会出现<strong>白</strong>对象漏标的情况，这种情况发生的前提是：</p>
<ul>
<li>Mutator赋予一个<strong>黑</strong>对象该<strong>白</strong>对象的引用。</li>
<li>Mutator删除了所有从<strong>灰</strong>对象到该<strong>白</strong>对象的直接或者间接引用。</li>
</ul>
<p>对于第一个条件，在并发标记阶段，如果该<strong>白</strong>对象是 <em>new</em> 出来的，并没有被<strong>灰</strong>对象持有，那么它会不会被漏标呢？Region中有两个 <em>top-at-mark-start(TAMS)</em> 指针，分别为 <em>prevTAMS</em> 和 <em>nextTAMS</em>。在 <em>TAMS</em> 以上的对象是新分配的，这是一种隐式的标记。对于在 <em>GC</em> 时已经存在的<strong>白</strong>对象，如果它是活着的，它必然会被另一个对象引用，即条件二中的<strong>灰</strong>对象。如果<strong>灰</strong>对象到<strong>白</strong>对象的直接引用或者间接引用被替换了，或者删除了，<strong>白</strong>对象就会被漏标，从而导致被回收掉，这是非常严重的错误，所以<em>SATB</em> 破坏了第二个条件。也就是说，一个对象的引用被替换时，可以通过 <em>Write Barrier</em> 将旧引用记录下来。</p>
<p><em>SATB</em> 也是有副作用的，如果被替换的<strong>白</strong>对象就是要被收集的垃圾，这次的标记会让它躲过GC，这就是 <em>float garbage</em>。因为 <em>SATB</em>的做法精度比较低，所以造成的 <em>Float Garbage</em> 也会比较多。</p>
<h3 id=rset---remembered-set>RSet - Remembered Set</h3>
<p>每个 <em>Region</em> 初始化时，会初始化一个 <em>Remembered Set</em> ，简称 <em>RSet</em>，该集合用来记录并跟踪其它 <em>Region</em> 指向该 <em>Region</em> 中对象的引用，每个 <em>Region</em> 默认按照 <em>512Kb</em> 划分成多个 <em>Card</em> ，所以 <em>RSet</em> 需要记录的东西应该是 <em>Region-n</em> 的 <em>Card-n</em>。</p>
<p><figure style=flex-grow:255;flex-basis:613px>
<a href=/p/jvm-gc-g1-1/g1-gc-rset.png data-size=552x216><img src=/p/jvm-gc-g1-1/g1-gc-rset.png srcset="/p/jvm-gc-g1-1/g1-gc-rset_hu01b0ff73c603091312ecf6f22959d7e1_15051_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/g1-gc-rset_hu01b0ff73c603091312ecf6f22959d7e1_15051_1024x0_resize_box_3.png 1024w" width=552 height=216 loading=lazy alt="JDK 8 G1 GC Remembered Set">
</a>
<figcaption>JDK 8 G1 GC Remembered Set</figcaption>
</figure></p>
<p><em>G1 GC</em> 将一组或多组区域（称为回收集 (<em>CSet</em>)）中的存活对象以增量、并行的方式复制到不同的新区域来实现压缩，从而减少堆碎片。目标是从可回收空间最多的区域开始，尽可能回收更多的堆空间，同时尽可能不超出暂停时间目标（垃圾优先）。</p>
<p><em>G1 GC</em> 使用独立的记忆集 (<em>RSet</em>) 跟踪对区域的引用。独立的 <em>RSet</em> 可以并行、独立地回收区域，因为只需要对区域（而不是整个堆）的 <em>RSet</em> 进行区域引用扫描。<em>G1 GC</em> 使用后 <em>Write Barrier</em> 记录堆的更改和更新 <em>RSet</em>。</p>
<h3 id=pause-prediction-model><em>Pause Prediction Model</em></h3>
<p><em>Pause Prediction Model</em> 即停顿预测模型，<em>G1</em> 使用暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数量。</p>
<p><em>G1 GC</em> 是一个响应时间优先的<em>GC</em> 算法，它与 <em>CMS</em> 最大的不同是，用户可以设定整个 <em>GC</em> 过程的期望停顿时间，参数 <code>-XX:MaxGCPauseMillis</code> 指定一个 <em>G1</em> 收集过程目标停顿时间，默认值 <code>200ms</code>，不过它不是硬性条件，只是期望值。那么 <em>G1</em> 怎么满足用户的期望呢？就需要这个停顿预测模型了。<em>G1</em> 根据这个模型统计计算出来的历史数据来预测本次收集需要选择的 <em>Region</em> 数量，从而尽量满足用户设定的目标停顿时间。 停顿预测模型是以衰减标准偏差为理论基础实现的。</p>
<h2 id=gc-过程><em>GC</em> 过程</h2>
<h3 id=gc-步骤><em>GC</em> 步骤</h3>
<h4 id=年轻代-gc>年轻代 <em>GC</em></h4>
<h5 id=g1中的年轻代>G1中的年轻代</h5>
<p>堆内存将被分割为大约 2000 个 <em>Region</em>。最小为 <em>1Mb</em>，最大为 <em>32Mb</em>，一般为 <em>1Mb</em> ， <em>2Mb</em> ， <em>4Mb</em> ， <em>8Mb</em> ， <em>16Mb</em> ， <em>32Mb</em> ，为 <em>2</em> 的倍数。</p>
<p><figure style=flex-grow:143;flex-basis:344px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-young-1.png data-size=461x321><img src=/p/jvm-gc-g1-1/jdk-g1-gc-young-1.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-young-1_hu4579304464d890321cad013eba65c39d_11637_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-young-1_hu4579304464d890321cad013eba65c39d_11637_1024x0_resize_box_3.png 1024w" width=461 height=321 loading=lazy alt="Young Generation in G1">
</a>
<figcaption>Young Generation in G1</figcaption>
</figure></p>
<h5 id=g1-中的-young-gc><em>G1</em> 中的 <em>Young GC</em></h5>
<p>存活对象被疏散（即，复制或移动）到一个或多个幸存区域。 如果满足老年化阈值，则将一些对象提升到老年代区域。</p>
<p><figure style=flex-grow:143;flex-basis:344px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-young-2.png data-size=461x321><img src=/p/jvm-gc-g1-1/jdk-g1-gc-young-2.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-young-2_hubb213a314f3a278b8545d59aea26657f_18417_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-young-2_hubb213a314f3a278b8545d59aea26657f_18417_1024x0_resize_box_3.png 1024w" width=461 height=321 loading=lazy alt="A Young GC in G1">
</a>
<figcaption>A Young GC in G1</figcaption>
</figure></p>
<p>这是一个 <em>STW</em> 的暂停。 为下一个 <em>Young GC</em> 计算 <em>Eden</em> 大小和 <em>Suvivor</em> 大小。 保留暂停时间目标之类的信息来帮助计算大小。</p>
<p>使用这样的方法可以很容易地调整区域的大小，根据需要弹性伸缩。</p>
<h5 id=young-gc-结束后><em>Young GC</em> 结束后</h5>
<p>存活对象被疏散到 <em>Survivor</em> 区域或 <em>Old</em> 区域。</p>
<p><figure style=flex-grow:143;flex-basis:344px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-young-3.png data-size=461x321><img src=/p/jvm-gc-g1-1/jdk-g1-gc-young-3.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-young-3_hubb213a314f3a278b8545d59aea26657f_14500_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-young-3_hubb213a314f3a278b8545d59aea26657f_14500_1024x0_resize_box_3.png 1024w" width=461 height=321 loading=lazy alt="End of Young GC in G1">
</a>
<figcaption>End of Young GC in G1</figcaption>
</figure></p>
<h5 id=总结>总结</h5>
<p>综上所述，关于 <em>G1</em> 中的年轻代有如下描述：</p>
<ul>
<li>
<p>堆是分割成区域的单个内存空间。</p>
</li>
<li>
<p>年轻代内存由一组不连续的区域组成。 能够在需要时调整大小。</p>
</li>
<li>
<p>年轻代垃圾回收，称为 <em>Young GC</em>，是 <em>STW</em> 事件，需要停止所有应用程序线程来进行操作。</p>
</li>
<li>
<p><em>Young GC</em> 使用多个线程并行完成。</p>
</li>
<li>
<p>存活对象被复制到新的 <em>Survivor</em> 或 <em>Old</em> 区域。</p>
</li>
</ul>
<h4 id=老年代-gc>老年代 GC</h4>
<p>与 <em>CMS GC</em> 一样，<em>G1 GC</em> 被设计为老年代对象的低暂停收集器。 下表描述了老年代的 <em>G1</em> 收集阶段。</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th><em>STW</em></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始标记</td>
<td><em>STW</em></td>
<td>对于 G1，它将在 <em>Young GC</em> 中运行。标记可能引用老年代对象的幸存者区域（根区域）。</td>
</tr>
<tr>
<td>根区域扫描</td>
<td></td>
<td>在 <em>Survivor</em> 区中扫描引用到老年代的引用。本阶段需要确保在 <em>Young GC</em> 发生前完成。</td>
</tr>
<tr>
<td>并发标记</td>
<td></td>
<td>在整个堆中寻找存活对象，此阶段可能会被 <em>Young GC</em> 打断。</td>
</tr>
<tr>
<td>再次标记</td>
<td><em>STW</em></td>
<td>使用 <em>SATB</em> 算法完成对堆中存对象的标记，该算法比 <em>CMS</em> 中的算法更快。</td>
</tr>
<tr>
<td>清理</td>
<td><em>STW</em></td>
<td>1. 记录存活对象和完全空白的区域。（STW）; 2. 清理 <em>RSet</em>。（STW）; 3. 重置空区域并将它们返回到空闲列表。 （并发）</td>
</tr>
<tr>
<td>复制</td>
<td><em>STW</em></td>
<td>这些是以 <em>STW</em> 的形式将存活对象疏散或复制到新的未使用区域。 <code>[GC pause (young)]</code>为完成 <em>Young GC</em> 的记录。或者是以<code>[GC Pause (mixed)]</code>为记录的年轻代和年老代区域。</td>
</tr>
</tbody>
</table>
<h5 id=初始标记>初始标记</h5>
<p>存活对象的初始标记将在 <em>Young GC</em> 中进行。在日志中，这被标记为 <code> GC pause (young)(inital-mark)</code>。</p>
<p><figure style=flex-grow:189;flex-basis:454px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-old-1.png data-size=381x201><img src=/p/jvm-gc-g1-1/jdk-g1-gc-old-1.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-old-1_hu6f9769434bfdd6f06be692baef3062cf_9646_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-old-1_hu6f9769434bfdd6f06be692baef3062cf_9646_1024x0_resize_box_3.png 1024w" width=381 height=201 loading=lazy alt="Initial Marking Phase">
</a>
<figcaption>Initial Marking Phase</figcaption>
</figure></p>
<h5 id=并发标记>并发标记</h5>
<p>如果发现空 <em>Region</em>（如“X”所示），则在 <em>再次标记</em> 阶段立即将其删除。此外，也将记录计算的确定活跃度信息。</p>
<p><figure style=flex-grow:189;flex-basis:454px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-old-2.png data-size=381x201><img src=/p/jvm-gc-g1-1/jdk-g1-gc-old-2.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-old-2_hu41e89c0647331901f00820fec540480a_12021_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-old-2_hu41e89c0647331901f00820fec540480a_12021_1024x0_resize_box_3.png 1024w" width=381 height=201 loading=lazy alt="Concurrent Marking Phase">
</a>
<figcaption>Concurrent Marking Phase</figcaption>
</figure></p>
<h5 id=再次标记>再次标记</h5>
<p>删除并回收空 <em>Region</em>，并计算所有 <em>Region</em> 的区域活跃度。</p>
<p><figure style=flex-grow:189;flex-basis:454px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-old-3.png data-size=381x201><img src=/p/jvm-gc-g1-1/jdk-g1-gc-old-3.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-old-3_hu5d70daf57bc3cb55ce24b0b7100a1806_9562_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-old-3_hu5d70daf57bc3cb55ce24b0b7100a1806_9562_1024x0_resize_box_3.png 1024w" width=381 height=201 loading=lazy alt="Remark Phase">
</a>
<figcaption>Remark Phase</figcaption>
</figure></p>
<h5 id=复制清理>复制/清理</h5>
<p><em>G1</em> 选择 “活跃度” 最低的 <em>Region</em> ，那些可以最快完成收集的 <em>Region</em> 。然后这些 <em>Region</em> 在 <em>Young GC</em> 进行的同时被收集。在日志中表示为 [GC pause (mixed)]。所以年轻代和年老代将被同时收集。</p>
<p><figure style=flex-grow:189;flex-basis:454px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-old-4.png data-size=381x201><img src=/p/jvm-gc-g1-1/jdk-g1-gc-old-4.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-old-4_hu3cdbceab84205a542c3ee74f970f615c_14261_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-old-4_hu3cdbceab84205a542c3ee74f970f615c_14261_1024x0_resize_box_3.png 1024w" width=381 height=201 loading=lazy alt="Copying/Cleanup Phase">
</a>
<figcaption>Copying/Cleanup Phase</figcaption>
</figure></p>
<h5 id=复制清理-后>复制/清理 后</h5>
<p>选定的区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域。</p>
<p><figure style=flex-grow:189;flex-basis:454px>
<a href=/p/jvm-gc-g1-1/jdk-g1-gc-old-5.png data-size=381x201><img src=/p/jvm-gc-g1-1/jdk-g1-gc-old-5.png srcset="/p/jvm-gc-g1-1/jdk-g1-gc-old-5_hua05330af37ba9fb257de0b5af069b983_9653_480x0_resize_box_3.png 480w, /p/jvm-gc-g1-1/jdk-g1-gc-old-5_hua05330af37ba9fb257de0b5af069b983_9653_1024x0_resize_box_3.png 1024w" width=381 height=201 loading=lazy alt="After Copying/Cleanup Phase">
</a>
<figcaption>After Copying/Cleanup Phase</figcaption>
</figure></p>
<h5 id=总结-1>总结</h5>
<p>这里有几个老年代 <em>GC</em> 的关键点:</p>
<ul>
<li>并发标记阶段
<ul>
<li>存活度信息是在程序运行期间并发计算的</li>
<li>存活度标明了在疏散暂停的时期哪些 <em>Region</em> 更适合被回收。</li>
<li>没有像 <em>CMS</em> 一样的清扫阶段</li>
</ul>
</li>
<li>再次标记阶段
<ul>
<li>使用了比 <em>CMS</em> 快很多的 <em>Snapshot-at-the-Beginning (SATB)</em> 算法</li>
<li>完全空白的 <em>Region</em> 将会被回收</li>
</ul>
</li>
<li>复制/清理阶段
<ul>
<li>年轻代和老年代将会在同一时间被回收</li>
<li>基于存活度选择需要回收的老年代 <em>Region</em></li>
</ul>
</li>
</ul>
<h3 id=gc-模式><em>GC</em> 模式</h3>
<h4 id=young-gc><em>Young GC</em></h4>
<p>选定所有年轻代里的 <em>Region</em> 。通过控制年轻代的 <em>Region</em> 个数，即年轻代内存大小，来控制<em>Young GC</em> 的时间开销。</p>
<h4 id=mixed-gc><em>Mixed GC</em></h4>
<p>选定所有年轻代里的 <em>Region</em> ，外加根据 <em>Global Concurrent Marking</em> 统计得出收集收益高的若干老年代 <em>Region</em> 。在用户指定的开销目标范围内尽可能选择收益高的老年代 <em>Region</em> 。</p>
<p><em>Mixed GC</em> 不是 <em>Full GC</em> ，它只能回收部分老年代的 <em>Region</em> ，如果 <em>Mixed GC</em> 实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行 <em>Mixed GC</em> ，就会使用 <em>Serial Old GC (Full GC)</em> 来收集整个 <em>GC heap</em> 。所以我们可以知道，<em>G1</em> 是不提供 <em>Full GC</em> 的。</p>
<h3 id=gc-日志><em>GC</em> 日志</h3>
<h4 id=启动参数>启动参数</h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>java -jar gs-service-0.0.1-SNAPSHOT.jar -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -XX:+PrintGCApplicationStoppedTime -XX:+PrintReferenceGC -Xloggc:/home/logs/gc/gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles<span class=o>=</span><span class=m>20</span> -XX:GCLogFileSize<span class=o>=</span>5M
</code></pre></div><table>
<thead>
<tr>
<th style=text-align:left>参数</th>
<th style=text-align:left>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>-XX:+PrintGCDetails</code></td>
<td style=text-align:left>打印 GC 详情</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+PrintGCDateStamps</code></td>
<td style=text-align:left>打印 GC 时间戳</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+PrintHeapAtGC</code></td>
<td style=text-align:left>打印 GC 时的堆信息</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+PrintTenuringDistribution</code></td>
<td style=text-align:left>在每次 <em>Young GC</em> 时，打印出幸存区中对象的年龄分布</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+PrintGCApplicationStoppedTime</code></td>
<td style=text-align:left>打印 GC 时应用停顿时间</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+PrintReferenceGC</code></td>
<td style=text-align:left>记录回收了多少不同引用类型的引用</td>
</tr>
<tr>
<td style=text-align:left><code>-Xloggc:/home/logs/gc/gc-%t.log</code></td>
<td style=text-align:left>指定 GC 日志位置与文件格式</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:+UseGCLogFileRotation</code></td>
<td style=text-align:left>启用滚动日志</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:NumberOfGCLogFiles=20</code></td>
<td style=text-align:left>最大日志数量</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:GCLogFileSize=5M</code></td>
<td style=text-align:left>单个日志最大大小</td>
</tr>
</tbody>
</table>
<h4 id=日志详情>日志详情</h4>
<pre><code>{Heap before GC invocations=0 (full 0):
 garbage-first heap   total 6291456K, used 313344K [0x0000000660800000, 0x0000000660a06000, 0x00000007e0800000)
  region size 2048K, 153 young (313344K), 0 survivors (0K)
 Metaspace       used 32143K, capacity 32576K, committed 33024K, reserved 1077248K
  class space    used 4199K, capacity 4318K, committed 4352K, reserved 1048576K
2021-08-04T17:09:15.956+0900: 4.167: [GC pause (G1 Evacuation Pause) (young), 0.0316564 secs]
   [Parallel Time: 15.5 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 4167.1, Avg: 4167.7, Max: 4168.1, Diff: 1.1]
      [Ext Root Scanning (ms): Min: 1.4, Avg: 2.9, Max: 4.9, Diff: 3.5, Sum: 11.5]
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.2]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.8, Max: 2.3, Diff: 2.3, Sum: 3.4]
      [Object Copy (ms): Min: 9.9, Avg: 10.6, Max: 12.4, Diff: 2.5, Sum: 42.5]
      [Termination (ms): Min: 0.0, Avg: 0.5, Max: 0.6, Diff: 0.6, Sum: 1.9]
         [Termination Attempts: Min: 1, Avg: 11.2, Max: 16, Diff: 15, Sum: 45]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [GC Worker Total (ms): Min: 14.4, Avg: 14.9, Max: 15.5, Diff: 1.0, Sum: 59.5]
      [GC Worker End (ms): Min: 4182.5, Avg: 4182.5, Max: 4182.6, Diff: 0.0]
   [Code Root Fixup: 0.1 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.2 ms]
   [Other: 15.8 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 14.3 ms]
      [Ref Enq: 0.1 ms]
      [Redirty Cards: 0.1 ms]
      [Humongous Register: 0.2 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.3 ms]
   [Eden: 306.0M(306.0M)-&gt;0.0B(278.0M) Survivors: 0.0B-&gt;28672.0K Heap: 306.0M(6144.0M)-&gt;26902.6K(6144.0M)]
Heap after GC invocations=1 (full 0):
 garbage-first heap   total 6291456K, used 26902K [0x0000000660800000, 0x0000000660a06000, 0x00000007e0800000)
  region size 2048K, 14 young (28672K), 14 survivors (28672K)
 Metaspace       used 32143K, capacity 32576K, committed 33024K, reserved 1077248K
  class space    used 4199K, capacity 4318K, committed 4352K, reserved 1048576K
}
</code></pre><table>
<thead>
<tr>
<th style=text-align:left>指标</th>
<th style=text-align:left>值</th>
<th style=text-align:left>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><em>GC</em> 原因</td>
<td style=text-align:left>GC pause (G1 Evacuation Pause) (young)</td>
<td style=text-align:left>发生 <em>Young GC</em></td>
</tr>
<tr>
<td style=text-align:left><em>GC</em> 时间</td>
<td style=text-align:left>0.0316564 secs</td>
<td style=text-align:left></td>
</tr>
<tr>
<td style=text-align:left><em>Eden</em> 区容量变化</td>
<td style=text-align:left>306.0M -> 278.0M</td>
<td></td>
</tr>
<tr>
<td style=text-align:left><em>Eden</em> 区大小变化</td>
<td style=text-align:left>306.0M -> 0.0B</td>
<td></td>
</tr>
<tr>
<td style=text-align:left><em>Survivor</em> 区容量变化</td>
<td style=text-align:left>0.0B -> 28672.0K</td>
<td></td>
</tr>
<tr>
<td style=text-align:left><em>Heap</em> 容量变化</td>
<td style=text-align:left>6144.0M -> 6144.0M</td>
<td></td>
</tr>
<tr>
<td style=text-align:left><em>Heap</em> 大小变化</td>
<td style=text-align:left>306.0M -> 26902.6K</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id=参数调整>参数调整</h2>
<h3 id=参数详解>参数详解</h3>
<table>
<thead>
<tr>
<th style=text-align:left>参数</th>
<th style=text-align:left>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>-XX:+UseG1GC</code></td>
<td style=text-align:left>启用<em>G1 GC</em></td>
</tr>
<tr>
<td style=text-align:left>`-XX:G1HeapRegionSize=n</td>
<td style=text-align:left>设置Region大小，并非最终值</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:MaxGCPauseMillis=200</code></td>
<td style=text-align:left>设置G1收集过程目标时间，默认值200ms，不是硬性条件</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1NewSizePercent=5</code></td>
<td style=text-align:left>新生代最小值，默认值5%</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1MaxNewSizePercent=60</code></td>
<td style=text-align:left>新生代最大值，默认值60%</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:ParallelGCThreads=n</code></td>
<td style=text-align:left><em>STW</em> 期间，并行GC线程数</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:ConcGCThreads=n</code></td>
<td style=text-align:left>并发标记阶段，并行执行的线程数</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:InitiatingHeapOccupancyPercent=45</code></td>
<td style=text-align:left>设置触发标记周期的 <em>Java</em> 堆占用率阈值。默认值是 <em>45%</em>。这里的 <em>Java</em> 堆占比指的是非 <em>Young Region</em> 的大小占比 ，包括 <em>Old</em> 与 <em>Humongous</em></td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1MixedGCLiveThresholdPercent=65</code></td>
<td style=text-align:left>为混合垃圾回收周期中要包括的旧区域设置占用率阈值，默认占用率为 <em>65%</em> 。</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1HeapWastePercent=10</code></td>
<td style=text-align:left>设置您愿意浪费的堆百分比。如果可回收百分比小于堆废物百分比，<em>Java HotSpot VM</em> 不会启动混合垃圾回收周期。默认值是 <em>10%</em>。</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1MixedGCCountTarget=8</code></td>
<td style=text-align:left>设置标记周期完成后，对存活数据上限为 <em>G1MixedGCLIveThresholdPercent</em> 的旧区域执行混合垃圾回收的目标次数。默认值是 <em>8</em> 次混合垃圾回收，混合回收的目标是要控制在此目标次数以内。</td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1OldCSetRegionThresholdPercent=10</code></td>
<td style=text-align:left>设置混合垃圾回收期间要回收的最大旧区域数，默认值是 <em>Java</em> 堆的 <em>10%。</em></td>
</tr>
<tr>
<td style=text-align:left><code>-XX:G1ReservePercent=10</code></td>
<td style=text-align:left>设置作为空闲空间的预留内存百分比，以降低目标空间溢出的风险,默认值是 <em>10%</em>。</td>
</tr>
</tbody>
</table>
<h3 id=建议>建议</h3>
<p>评估和微调 <em>G1 GC</em> 时，请记住以下建议：</p>
<ul>
<li>
<p><strong>年轻代大小</strong>：避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p>
</li>
<li>
<p><strong>暂停时间目标</strong>：每当对垃圾回收进行评估或调优时，都会涉及到延迟与吞吐量的权衡。<em>G1 GC</em> 是增量垃圾回收器，暂停统一，同时应用程序线程的开销也更多。<em>G1 GC</em> 的吞吐量目标是 <em>90%</em> 的应用程序时间和 <em>10%</em> 的垃圾回收时间。如果将其与 <em>Java HotSpot VM</em> 的吞吐量回收器相比较，目标则是 <em>99%</em> 的应用程序时间和 <em>1%</em> 的垃圾回收时间。因此，当您评估 <em>G1 GC</em> 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示您愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量。当您评估 <em>G1 GC</em> 的延迟时，请设置所需的（软）实时目标，<em>G1 GC</em> 会尽量满足。副作用是，吞吐量可能会受到影响。</p>
</li>
<li>
<p>掌握混合垃圾回收：当您调优混合垃圾回收时，请尝试以下选项：</p>
<ul>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 用于更改标记阈值。</li>
<li><code>-XX:G1MixedGCLiveThresholdPercent 和 -XX:G1HeapWastePercent</code> 当您想要更改混合垃圾回收决定时。</li>
<li><code>-XX:G1MixedGCCountTarget</code> 和 <code>-XX:G1OldCSetRegionThresholdPercent</code> 当您想要调整旧区域的 <em>CSet</em> 时。</li>
</ul>
</li>
</ul>
<h2 id=总结-2>总结</h2>
<p><em>G1 GC</em> 是区域化、并行-并发、增量式垃圾回收器，相比其他 <em>HotSpot</em> 垃圾回收器，可提供更多可预测的暂停。增量的特性使 <em>G1 GC</em> 适用于更大的堆，在最坏的情况下仍能提供不错的响应。<em>G1 GC</em> 的自适应特性使 <em>JVM</em> 命令行只需要软实时暂停时间目标的最大值以及 <em>Java</em> 堆大小的最大值和最小值，即可开始工作。</p>
<h2 id=参考>参考</h2>
<ol>
<li><a class=link href=https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html target=_blank rel=noopener>Getting Started with the G1 Garbage Collector</a></li>
<li><a class=link href=https://www.oracle.com/java/technologies/javase/hotspot-garbage-collection.html target=_blank rel=noopener>The Garbage First Garbage Collector</a></li>
<li><a class=link href=https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html target=_blank rel=noopener>垃圾优先型垃圾回收器调优</a></li>
<li><a class=link href=https://tech.meituan.com/2016/09/23/g1.html target=_blank rel=noopener>Java Hotspot G1 GC的一些关键技术</a></li>
<li><a class=link href=https://blog.didispace.com/step-by-step-g1/ target=_blank rel=noopener>一步步图解G1</a></li>
<li><a class=link href=https://github.com/authorNari/g1gc-impl-book target=_blank rel=noopener>徹底解剖「G1GC」実装編</a></li>
<li><a class=link href=https://www.redhat.com/zh/blog/part-1-introduction-g1-garbage-collector target=_blank rel=noopener>Part 1: Introduction to the G1 Garbage Collector</a></li>
<li><a class=link href=https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2 target=_blank rel=noopener>Collecting and reading G1 garbage collector logs - part 2</a></li>
</ol>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/jvm/>JVM</a>
<a href=/tags/gc/>GC</a>
<a href=/tags/g1/>G1</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<section class=article-lastmod><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>
最后更新于 Aug 19, 2021 10:35 +0800
</span>
</section></footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/p/jvm-2/>
<div class=article-image>
<img src=/p/jvm-2/jvm-white.d67a4564541185256725d5208b902a63_hu06bdc8659dce216bb36458f3911d03ef_23035_250x150_fill_q75_box_smart1.jpg width=250 height=150 loading=lazy data-key=jvm-2 data-hash="md5-1npFZFQRhSVnJdUgi5AqYw==">
</div>
<div class=article-details>
<h2 class=article-title>JVM调优（二）</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2016 -
2021 Catfish
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.1.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">目录</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#重要概念>重要概念</a>
<ol>
<li><a href=#region>Region</a></li>
<li><a href=#stab>STAB</a></li>
<li><a href=#rset---remembered-set>RSet - Remembered Set</a></li>
<li><a href=#pause-prediction-model><em>Pause Prediction Model</em></a></li>
</ol>
</li>
<li><a href=#gc-过程><em>GC</em> 过程</a>
<ol>
<li><a href=#gc-步骤><em>GC</em> 步骤</a>
<ol>
<li><a href=#年轻代-gc>年轻代 <em>GC</em></a></li>
<li><a href=#老年代-gc>老年代 GC</a></li>
</ol>
</li>
<li><a href=#gc-模式><em>GC</em> 模式</a>
<ol>
<li><a href=#young-gc><em>Young GC</em></a></li>
<li><a href=#mixed-gc><em>Mixed GC</em></a></li>
</ol>
</li>
<li><a href=#gc-日志><em>GC</em> 日志</a>
<ol>
<li><a href=#启动参数>启动参数</a></li>
<li><a href=#日志详情>日志详情</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#参数调整>参数调整</a>
<ol>
<li><a href=#参数详解>参数详解</a></li>
<li><a href=#建议>建议</a></li>
</ol>
</li>
<li><a href=#总结-2>总结</a></li>
<li><a href=#参考>参考</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>