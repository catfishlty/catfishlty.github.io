<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GC on Catfish</title><link>https://www.catfish.top/categories/gc/</link><description>Recent content in GC on Catfish</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 09 Aug 2021 10:33:00 +0800</lastBuildDate><atom:link href="https://www.catfish.top/categories/gc/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM 垃圾回收器 - G1</title><link>https://www.catfish.top/p/jvm-gc-g1-1/</link><pubDate>Mon, 09 Aug 2021 10:33:00 +0800</pubDate><guid>https://www.catfish.top/p/jvm-gc-g1-1/</guid><description>G1 GC G1 GC，全称 Garbage-First Garbage Collector，通过 -XX:+UseG1GC参数来启用。 它是专门针对以下应用场景设计的:
像 CMS 收集器一样，能与应用程序线程并发执行。 整理空闲空间更快。 需要 GC 停顿时间更好预测。 不希望牺牲大量的吞吐性能。 不需要更大的 Java 堆内存。 G1 收集器的设计目标是取代 CMS 收集器，它同 CMS 相比，在以下方面表现的更出色： G1 是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。 G1 的 Stop The World(STW) 更可控，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。
重要概念 Region 传统的 GC 收集器将连续的内存空间划分为新生代、老年代和永久代（JDK 8 去除了永久代，引入了元空间 Metaspace ），这种划分的特点是各代的存储地址（逻辑地址，下同）是连续的。如下图所示：
JDK 8 Memory Structure
而 G1 的各代存储地址是不连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个* Region* 占有一块连续的虚拟内存地址。如下图所示：
JDK 8 G1 GC Memory Structure
G1 的堆结构就是把一整块内存区域切分成多个固定大小的块，每一块被称为一个 Region 。在JVM在启动时来决定每个小块，也就是 Region 的大小。 JVM一般是把一整块堆切分成大约 2000 个 Region 。每个小 Region 从 1 到 32Mb 不等，且是 2 的指数，如果不设定，那么G1会根据Heap大小自动决定。这些 Region 最后又被分别标记为Eden , Survivor 和 Old 。这里的 Eden ， Survivor 和old已经是一个标签，也就是说只是一个逻辑表示，不是物理表示。O表示老生代（ Old ），E表示 Eden ，S表示 Survivor 。为了明了，我们分别用三种不同的颜色区分。存活下来的对象就被虚拟机从一个 Region 里被移动到另一个中。这些小块 Region 的回收是并行回收的，期间其他的应用线程照常工作。和以往的回收器一样， G1 中也有 Eden , Survivor , Old 。在这三个之外，还增加了第四种类型，叫 Humongous 。这个单词翻译过来就是“堆积如山”的意思。这个类型主要是用来存储那些比标准块大50%，甚至更大的那些对象。这些大对象被保存到一整块连续的区域。这个堆积如山区就是堆里没有被使用的区域。记住一点： G1 不是像老一辈的那些垃圾回收器一样要求每一代的块是连续的，在 G1 中可以不是连续的。</description></item></channel></rss>